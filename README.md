# Кэшириующий DNS сервер

Эта программа представляет собой кэширующий DNS сервер. Основная цель - уменьшить задержки и нагрузку на сеть за счет локального кэширования DNS-запросов.

## Описание

Программа кэширует результаты DNS-запросов, чтобы при повторных запросах кэшированные ответы выдавались быстрее, не обращаясь к корневым DNS-серверам повторно. В случае отсутствия кэшированных данных запрос направляется к публичным DNS-серверам, таким как Google DNS.

## Требования

Для запуска проекта необходимы:
- Python 3.6+
- Файл `dns_cache.json` (будет автоматически создан при первом запуске)

## Установка

Склонируйте репозиторий и перейдите в папку проекта:
```bash
git clone <URL>
cd <project-directory>
```

## Запуск проекта

Для запуска сервера выполните следующую команду:
```bash
python main.py
```

## Примеры использования

1. **Первичный запрос:**
   В первом случае, когда доменное имя отсутствует в кэше, запрос направляется на верхний DNS сервер (например, Google DNS 8.8.8.8). 

2. **Повторный запрос:**
   При повторном запросе того же доменного имени данные сразу возвращаются из кэша, без обращения к верхнему DNS серверу.

### Пример:

Пример запроса к DNS серверу с использованием инструмента `dig`.

**Первый запрос:**
```
$ dig @localhost example.com
```
- Ответ будет запрошен у верхнего DNS сервера и закэширован.

**Повторный запрос:**
```
$ dig @localhost example.com
```
- Ответ будет возвращен из кэша, уменьшая задержку.



### JSON файл

Файл `dns_cache.json` нужен для хранения кэшированных DNS-данных между запусками программы. Структура файла:

```json
{
  "dns_cache": {
    "example.com": {
      "ttl": 1622548800,
      "response": "..."  // закодированный ответ DNS
    }
  },
  "reverse_dns_cache": {
    "93.184.216.34": {
      "ttl": 1622548800,
      "response": "..."  // закодированный ответ DNS
    }
  }
}
```

### Дополнение кода

1. Программа запускает поток для периодической очистки кэша (`cache_cleanup`).
2. Основной цикл сервера обрабатывает входящие UDP-запросы.
3. В случае прерывания (например, `KeyboardInterrupt`), сохраняется состояние кэша.

### Примеры запуска

#### Пример 1: Обработка обычного DNS запроса для домена.

Запрос:
```python
$ dig @localhost example.com
```

Ответ (первый раз):
- Запрос отправляется на внешние DNS и возвращается результат.

Ответ (повторный запрос):
- Результат возвращается из локального кэша.

#### Пример 2: Проверка и удаление устаревших записей.

Кэшированные записи будут автоматически очищаться через заданное время (TTL).

JSON файл до очистки:
```json
{
  "dns_cache": {
    "example.com": {
      "ttl": 1622548800,  // устарело
      "response": "..."
    }
  },
  "reverse_dns_cache": {}
}
```

JSON файл после очистки:
```json
{
  "dns_cache": {},
  "reverse_dns_cache": {}
}
```

Программа автоматически удаляет устаревшие записи каждые 60 секунд.

#### Основные компоненты кода:

- Импорты библиотек:
  Проект использует стандартные библиотеки Python, такие как socket, threading, и json.

- Функция load_cache():
  Загружает кэшированные DNS-запросы из файла dns_cache.json, если таковой существует. Это позволяет сохранять кэш между перезапусками сервера.

- Функция save_cache():
  Сохраняет текущий кэш в файл dns_cache.json. Это используется при остановке сервера для обеспечения сохранности данных.

- Функция handle_request(data, addr, sock):
  Обрабатывает входящий DNS-запрос. Проверяет кэш на наличие ответа. Если ответ есть в кэше, он направляет его обратно клиенту, если нет - пересылает запрос к внешнему DNS серверу, кэширует результат и затем отвечает клиенту.

- Функция cache_response(domain, response):
  Сохраняет ответ DNS-запроса в кэш вместе с текущим временем и временем жизни (TTL).

- Функция cache_cleanup():
  Постоянно работающий поток, очищающий устаревшие записи каждые 60 секунд.

- Основная функция main():
  1. Создает UDP сокет для прослушивания входящих DNS-запросов.
  2. Загружает существующий кэш из файла.
  3. Запускает поток для периодической очистки кэша.
  4. В цикле обрабатывает входящие DNS-запросы.
  5. Обрабатывает исключения для безопасной остановки сервера и сохранения кэша.